<!DOCTYPE html><html lang="fr"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Le design pattern Strategy et le Compiler Pass de Symfony</title><meta name="description" content="Introduction Avant de commencer, voici une brève description d’un projet sur lequel nous avons travaillé : Cléa. Cléa, c’est quoi ? C’est une application, développée pour notre client Qualitel, qui a pour vocation de fournir aux occupants des informations et des services pour le bon&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://gwennael-jean.github.io/le-design-pattern-strategy-et-le-compiler-pass-de-symfony.html"><link rel="alternate" type="application/atom+xml" href="https://gwennael-jean.github.io/feed.xml"><link rel="alternate" type="application/json" href="https://gwennael-jean.github.io/feed.json"><meta property="og:title" content="Design pattern Strategy et Compiler Pass"><meta property="og:site_name" content="Le blog de gwenn"><meta property="og:description" content="Introduction Avant de commencer, voici une brève description d’un projet sur lequel nous avons travaillé : Cléa. Cléa, c’est quoi ? C’est une application, développée pour notre client Qualitel, qui a pour vocation de fournir aux occupants des informations et des services pour le bon&hellip;"><meta property="og:url" content="https://gwennael-jean.github.io/le-design-pattern-strategy-et-le-compiler-pass-de-symfony.html"><meta property="og:type" content="article"><style>:root{--body-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--heading-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--logo-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";--menu-font:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol"}</style><link rel="stylesheet" href="https://gwennael-jean.github.io/assets/css/style.css?v=c67e26389eb6b774845b5f0611dabaee"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://gwennael-jean.github.io/le-design-pattern-strategy-et-le-compiler-pass-de-symfony.html"},"headline":"Design pattern Strategy et Compiler Pass","datePublished":"2022-01-11T11:10","dateModified":"2022-01-24T09:55","description":"Introduction Avant de commencer, voici une brève description d’un projet sur lequel nous avons travaillé : Cléa. Cléa, c’est quoi ? C’est une application, développée pour notre client Qualitel, qui a pour vocation de fournir aux occupants des informations et des services pour le bon&hellip;","author":{"@type":"Person","name":"Gwennael Jean"},"publisher":{"@type":"Organization","name":"Gwennael Jean"}}</script></head><body><div class="site-container"><header class="top" id="js-header"><a class="logo" href="https://gwennael-jean.github.io/">Le blog de gwenn</a></header><main><article class="post"><div class="hero"><header class="hero__content"><div class="wrapper"><div class="post__meta"><time datetime="2022-01-11T11:10">janvier 11, 2022</time></div><h1>Design pattern Strategy et Compiler Pass</h1><div class="post__meta post__meta--author"><a href="https://gwennael-jean.github.io/authors/gwennael-jean/" class="feed__author invert">Gwennael Jean</a></div></div></header></div><div class="wrapper post__entry"><h1 id="introduction">Introduction</h1><p>Avant de commencer, voici une brève description d’un projet sur lequel nous avons travaillé : Cléa.</p><p>Cléa, c’est quoi ? C’est une application, développée pour notre client Qualitel, qui a pour vocation de fournir aux occupants des informations et des services pour le bon usage de leur logement et le maintien de sa qualité dans le temps.</p><p>L’application permet à un propriétaire de :</p><ul><li>Saisir différentes caractéristiques de son logement</li><li>Déposer et partager différents documents</li><li>Garder en mémoire différents intervenants (constructeur, électricien, plombier, …)</li><li>Et plein d’autres encore …</li></ul><p>Une des fonctionnalités développées est d’obtenir et d’afficher les consommations de son logement. Au départ, il n’était possible que de saisir manuellement le relevé de son compteur (électrique, gaz ou autre). Les consommations étant calculées selon la saisie de ces relevés.</p><p>Puis une mise à jour est arrivé. Notre client nous a demandé de récupérer les consommations depuis les compteurs Linky et Gazpar. Mais comment le faire sans toucher au code déjà fonctionnel ?</p><p>La solution : <strong>Le design pattern Strategy</strong>.</p><h1 id="le-design-pattern-strategy">Le design pattern Strategy</h1><p>Le design pattern Strategy est un patron de conception permettant la sélection et l’exécution d’algorithmes selon certaines conditions, le tout en respectant l’un des principes SOLID, le Single Responsability (la responsabilité unique).</p><p>Nous aurons donc un service qui sera chargé d’exécuter ces différents algorithmes. Nous nommerons ce service <code>ExternalConsommationProvider</code>. Chaque algorithmes sera représenté par un service que nous appelerons provider. Un provider aura pour objectif de nous fournir les consommations d’une certaine catégorie.</p><p>Dans notre exemple, nous aurons 2 providers :</p><ul><li><code>EnedisDataConnectProvider</code> : Qui nous retournera les consommations de notre compteur Linky.</li><li><code>GrdfGazparProvider</code> : Qui nous retournera les consommations de notre compteur Gazpar.</li></ul><p>Voici un schéma pour mieux comprendre :</p><p></p><figure class="post__image"><img loading="lazy" src="https://gwennael-jean.github.io/media/posts/1/UML-Strategy-2.png" sizes="(max-width: 48em) 100vw, 768px" srcset="https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-xs.png 300w, https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-sm.png 480w, https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-md.png 768w, https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-lg.png 1024w, https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-xl.png 1360w, https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-2xl.png 1600w" alt="Image description" width="643" height="361"></figure><p></p><p>Sur ce diagramme, nous retrouvons notre service <code>ExternalConsommationProvider</code> (Le gros bloc jaune toute en haut). Celui-ci contiendra une liste de providers (la propriété visible via le petit carré rouge). Chaque provider sera une instance de <code>ConsommationProviderInterface</code> (le bloc jaune au milieu). Ce qui obligera chaque provider de développer 2 méthodes (<code>support()</code> et <code>findByRange()</code>). Enfin, nous retrouvons nos 2 providers <code>EnedisDataConnectProvider</code> et <code>GrdfGazparProvider</code> (chacun implémentant l’interface en question, symbolisé par la flèche en pointillé).</p><p>L’objectif de notre service <code>ExternalConsommationProvider</code> est, via sa méthode <code>findByRange</code>, de nous retourner les consommations. Sans même avoir développer nos 2 providers, nous pouvons déjà développer cette méthode :</p><pre><code class="language-php">public function findByRange(Logement $logement, DateTime $start, DateTime $end, User $user): array
{
    $consommations = [];

    foreach ($this-&gt;getProviders() as $provider) {
        if ($provider-&gt;support($logement, $user)) {
            $consommations = array_merge(
                $consommations,
                $provider-&gt;findByRange($logement, $start, $end, $user)
            );
        }
    }

    return $consommations;
}
</code></pre><p>Voyons ce code : on boucle sur les providers de notre service. Si chaque provider est supporté (pour résumer, si l’utilisateur souhaite obtenir les consommations depuis ce provider), on ajoute dans notre tableau <code>$consommations</code> les consommations récupéré grâce au provider.</p><p>En ce qui concerne nos providers, il suffit de développer les méthodes obtenues grâce à notre interface :</p><pre><code class="language-php">class EnedisDataConnectProvider implements ConsommationProviderInterface
{
    public function support(Logement $logement, User $user): bool
    {
        // On vérifie si notre logement est bien connecté au compteur Linky
    }

    public function findByRange(Logement $logement, DateTime $start, DateTime $end, User $user): array
    {
        // On retourne les consommations de notre compteur Linky grâce à l&#39;API Data Connect d&#39;Enedis
    }
}
</code></pre><p>Maintenant que nous avons implémenté notre service <code>ExternalConsommationProvider</code> ainsi que nos 2 providers, comment intégrer ces providers dans notre service ?</p><p>C’est là qu’intervient le Compiler Pass de Symfony.</p><h1 id="le-compiler-pass">Le Compiler Pass</h1><p>Pour ajouter un provider à notre service, nous disposons de la méthode <code>addProvider()</code>, qui attends en paramètre une instance de <code>ConsommationProviderInterface</code>.</p><p>Avec Symfony, nous avons la possibilité de tagger nos services, afin de les identifier plus facilement dans notre application.</p><p>Nous allons donc ajouter un tag sur tous nos services implémentant l’interface <code>ConsommationProviderInterface</code>. Pour cela, il suffit d’ajouter les lignes suivantes dans notre fichier <code>config/services.yaml</code> :</p><pre><code class="language-yaml">_instanceof:
  App\Service\ConsommationProviderInterface:
    tags: [ app.rt2012.external_consommation_provider ]
</code></pre><p>Ainsi, nos 2 providers auront le tags <code>app.rt2012.external_consommation_provider</code>.</p><p>Maintenant que nous pouvons identifier nos providers, nous pouvons créer un CompilerPass. Pour cela, Créons la class <code>ExternalConsommationProviderPass</code> comme ceci :</p><pre><code class="language-php">class ExternalConsommationProviderPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        if (!$container-&gt;has(ExternalConsommationProvider::class)) {
            return;
        }

        $definition = $container-&gt;findDefinition(ExternalConsommationProvider::class);

        $taggedServices = $container-&gt;findTaggedServiceIds(&#39;app.rt2012.external_consommation_provider&#39;);

        foreach ($taggedServices as $id =&gt; $tags) {
            $definition-&gt;addMethodCall(&#39;addProvider&#39;, [new Reference($id)]);
        }
    }
}
</code></pre><p>Dans notre méthode <code>process()</code>, nous vérifions si le service <code>ExternalConsommationProvider</code> existe. Ensuite, nous récupérons tous les services tagués sous le nom <code>app.rt2012.external_consommation_provider</code>, soit nos 2 providers. Enfin, nous bouclons sur ces services pour les ajouter dans notre service <code>ExternalConsommationProvider</code> grâce à la méthode <code>addProvider()</code>.</p><p>Pour terminer, il faut que notre application prenne en compte ce CompilerPass. Pour cela, il suffit de l’ajouter dans le container, via la méthode <code>build</code> de la class <code>App\Kernel</code> :</p><pre><code class="language-php">class Kernel extends BaseKernel
{
    public function build(ContainerBuilder $container)
    {
        $container-&gt;addCompilerPass(new ExternalConsommationProviderPass());
    }
}
</code></pre><h2 id="conclusion">Conclusion</h2><p>L’intérêt principal du design pattern Strategy est de nous permettre d’ajouter autant de provider que nous le souhaitons. Imaginons que, demain, Qualitel nous demande d’afficher les consommations d’une autre API, nous n’aurons qu’à créer un provider implémentant l’interface <code>ConsommationProviderInterface</code>. Celui-ci sera automatiquement tagué et inséré dans notre service <code>ExternalConsommationProvider</code> grâce au CompilerPass.</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on janvier 24, 2022</p><ul class="post__tag"><li><a href="https://gwennael-jean.github.io/tags/developpement/">Développement</a></li></ul><div class="post__share"></div><div class="post__bio bio"><div class="bio__info"><h3 class="bio__name"><a href="https://gwennael-jean.github.io/authors/gwennael-jean/" class="invert" rel="author">Gwennael Jean</a></h3></div></div></footer></article><nav class="post__nav"><div class="post__nav-inner"><div class="post__nav-next"><a href="https://gwennael-jean.github.io/les-commentaires.html" class="invert post__nav-link" rel="next"><span>Next</span> Les commentaires </a><svg width="1.041em" height="0.416em" aria-hidden="true"><use xlink:href="https://gwennael-jean.github.io/assets/svg/svg-map.svg#arrow-next"/></svg></div></div></nav></main><footer class="footer"><div class="footer__copyright">Powered by Publii</div><button class="footer__bttop js-footer__bttop" aria-label="Back to top"><svg><title>Back to top</title><use xlink:href="https://gwennael-jean.github.io/assets/svg/svg-map.svg#toparrow"/></svg></button></footer></div><script>window.publiiThemeMenuConfig = {    
        mobileMenuMode: 'sidebar',
        animationSpeed: 300,
        submenuWidth: 'auto',
        doubleClickTime: 500,
        mobileMenuExpandableSubmenus: true, 
        relatedContainerForOverlayMenuSelector: '.top',
   };</script><script defer="defer" src="https://gwennael-jean.github.io/assets/js/scripts.min.js?v=48e9576b9741cf2a93ab25c5689c9f5d"></script><script>var images = document.querySelectorAll('img[loading]');

        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>
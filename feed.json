{
    "version": "https://jsonfeed.org/version/1",
    "title": "Le blog de gwenn",
    "description": "",
    "home_page_url": "https://gwennael-jean.github.io",
    "feed_url": "https://gwennael-jean.github.io/feed.json",
    "user_comment": "",
    "author": {
        "name": "Gwennael Jean"
    },
    "items": [
        {
            "id": "https://gwennael-jean.github.io/rgpd-et-cookies-definition-reglementation-et-solutions-a-mettre-en-place.html",
            "url": "https://gwennael-jean.github.io/rgpd-et-cookies-definition-reglementation-et-solutions-a-mettre-en-place.html",
            "title": "RGPD et cookies : Définition, règlementation et solutions à mettre en place",
            "summary": "Introduction Au tout début de l’air d’internet, chaque requete HTTP était “sans état”. Il était donc impossible de garder en mémoire les informations d’un utilisateur. En 1994, C’est l’avenement d’internet. Les développeurs de netscape travaillent sur le développement d’un serveur perettant la mise ne place&hellip;",
            "content_html": "<h1 id=\"introduction\">Introduction</h1>\n<p>Au tout début de l’air d’internet, chaque requete HTTP était “sans état”. Il était donc impossible de garder en mémoire les informations\nd’un utilisateur.</p>\n<p>En 1994, C’est l’avenement d’internet.</p>\n<p>Les développeurs de netscape travaillent sur le développement d’un serveur perettant la mise ne place de sites e-commerce.\nCependant, les développeurs se retrouvent face à un problème :\nComment garder en mémoire l’état du panier d’achat du client.</p>\n<p>C’est alors que Lou Montulli et John Giannandrea urent une idée. Ils proposent de stocker un état dans un fichier.</p>\n<p>Le cookie est né.</p>\n<p>L’idée est simple : Le serveur dépose un fichier sur l’ordinateur du client.\nCelui-ci renverra ce fichier à chacune de ses requête HTTP.\nLe serveur aura ainsi la possibilité d’identifier l’utilisateur et ainsi, enregistrer l’état de son panier.</p>\n<p>Depuis, le cookie à évolué et des questions concernant le respect de la vie privée se posent, et aujourd’hui, c’est Facebook, Google et Youtube qui font les frais. Une amende de 150 000 000 d’euros à été infligé à Google. En effet, il est facile d’accepter ou refuser, mais très difficile de modifier ses choix.\nIls ont 3 mois pour faire les modifications. Au delà, c’est 100 000 € par jour de retard.</p>\n<blockquote>\n<p>La CNIL est une autorité administrative française chargée de veiller à ce que l’informatique soit au service du citoyen et qu’elle ne porte atteinte ni à l’identité humaine, ni aux droits de l’homme, ni à la vie privée, ni aux libertés individuelles ou publiques.</p>\n</blockquote>\n<h1 id=\"quest-ce-quun-cookies\">Qu’est ce qu’un cookies</h1>\n<p>Un cookie est un fichier qui permet de tracer et analyser le comportement de l’utilisateur.</p>\n<p>Il existe 3 grands types de cookie :</p>\n<table>\n<thead>\n<tr>\n<th>Type</th>\n<th>Info</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cookies de fonctionnement</td>\n<td>Necessaire au bon fonctionnement du site</td>\n</tr>\n<tr>\n<td>Cookies d’analyse</td>\n<td>Obligation du concentement de l’utilisateur</td>\n</tr>\n<tr>\n<td>Cookies publicitaires</td>\n<td>Obligation du concentement de l’utilisateur</td>\n</tr>\n</tbody></table>\n<p>Les cookies publicitaires sont ceux qui posent le plus de problème.</p>\n<blockquote>\n<p>Pourquoi un cookie s’appelle ainsi ? En reference au “fortune cookie” (biscuit chinois) qui contenait un petit message à l’intérieur.</p>\n</blockquote>\n<p>Il existe un certain flou juridique sur le consentement des cookies qui consiste à forcer l’utilisateur a accepter les cookies,\nou bien de payer une certaines sommes. Ce système à rapporté énormément d’argent à ces entreprises.\nEn tant qu’utilisateur, et avec ce système, est-ce que mon consentement est libre ? Au sein de la CNIL, il y a débat (c’est compliqué. D’un point de vu éthique, ca se discute).</p>\n<h1 id=\"le-cadre-reglementaire-applicable\">Le cadre reglementaire applicable</h1>\n<ul>\n<li>Les cookies doivent être déposé <em>après</em> le consentement</li>\n<li>La simple poursuite de la navigation sur le site ne peut plus être vu comme une acceptation du consentement</li>\n<li>La modification du consentement doit être aussi simple que le consentement lui même</li>\n<li>Date de validité de cookie : 13 mois</li>\n<li>Le bouton de refus est obligatoire (mais il peut être plus petit que les autres bouton)</li>\n</ul>\n<blockquote>\n<p>Bien que le bouton “refuser” est obligatoire, la petite asctuce est de le rendre plus petit que le bouton “accepter”.</p>\n</blockquote>\n<p>Consentement necessaire :</p>\n<ul>\n<li>Cookies pour la publicité ciblée</li>\n<li>Cookies de mesures d’audience (sauf exemptions)</li>\n<li>Cookies des réseaux sociaux</li>\n</ul>\n<p>Consentement non nécessaire :</p>\n<ul>\n<li>Cookies strictement nécessaires à la fourniture d’un service expressement demandés par l’utilisateur (cookies d’authentification, panier d’achats)<h1 id=\"les-solutions-a-mettre-en-place\">Les solutions a mettre en place</h1>\n</li>\n<li>Avoir une page dédié à la gestion des cookies (avec un tableau en 2 colonnes : Nom du cookies / Finalité)</li>\n<li>Il existe plein d’outils de gestion des cookies : Rarteaucitron, Axeptio, Consent Manager (Quantcast est déconseillé)</li>\n<li>Sans paramétrage, Google Analytics nécessite le consentement (Il faut changer la localisation (pas plus précis que la récupération de la ville) et l’IP pour évité le consentement).</li>\n<li>Matomo, Abla Analytics ne nécessite pas de consentement.</li>\n</ul>\n",
            "author": {
                "name": "Gwennael Jean"
            },
            "tags": [
                   "Développement"
            ],
            "date_published": "2022-01-27T14:55:11+01:00",
            "date_modified": "2022-01-28T16:51:17+01:00"
        },
        {
            "id": "https://gwennael-jean.github.io/le-design-pattern-strategy-et-le-compiler-pass-de-symfony.html",
            "url": "https://gwennael-jean.github.io/le-design-pattern-strategy-et-le-compiler-pass-de-symfony.html",
            "title": "Design pattern Strategy et Compiler Pass",
            "summary": "Introduction Avant de commencer, voici une brève description d’un projet sur lequel nous avons travaillé : Cléa. Cléa, c’est quoi ? C’est une application, développée pour notre client Qualitel, qui a pour vocation de fournir aux occupants des informations et des services pour le bon&hellip;",
            "content_html": "<h1 id=\"introduction\">Introduction</h1>\n<p>Avant de commencer, voici une brève description d’un projet sur lequel nous avons travaillé : Cléa.</p>\n<p>Cléa, c’est quoi ? C’est une application, développée pour notre client Qualitel, qui a pour vocation de\nfournir aux occupants des informations et des services pour le bon usage de leur logement et le\nmaintien de sa qualité dans le temps.</p>\n<p>L’application permet à un propriétaire de :</p>\n<ul>\n<li>Saisir différentes caractéristiques de son logement</li>\n<li>Déposer et partager différents documents</li>\n<li>Garder en mémoire différents intervenants (constructeur, électricien, plombier, …)</li>\n<li>Et plein d’autres encore …</li>\n</ul>\n<p>Une des fonctionnalités développées est d’obtenir et d’afficher les consommations de son logement.\nAu départ, il n’était possible que de saisir manuellement le relevé de son compteur (électrique, gaz ou autre).\nLes consommations étant calculées selon la saisie de ces relevés.</p>\n<p>Puis une mise à jour est arrivé.\nNotre client nous a demandé de récupérer les consommations depuis les compteurs Linky et Gazpar.\nMais comment le faire sans toucher au code déjà fonctionnel ?</p>\n<p>La solution : <strong>Le design pattern Strategy</strong>.</p>\n<h1 id=\"le-design-pattern-strategy\">Le design pattern Strategy</h1>\n<p>Le design pattern Strategy est un patron de conception permettant la sélection et l’exécution d’algorithmes\nselon certaines conditions, le tout en respectant l’un des principes SOLID, le Single Responsability\n(la responsabilité unique). Pour info, ce principe veut qu’un service ne réponde qu’a un seul et unique objectif.</p>\n<p>Nous aurons donc un service qui sera chargé d’exécuter ces différents algorithmes.\nNous nommerons ce service <code>ExternalConsommationProvider</code>.\nChaque algorithmes sera représenté par un service que nous appelerons provider.\nUn provider aura pour objectif de nous fournir les consommations d’une certaine catégorie.</p>\n<p>Dans notre exemple, nous aurons 2 providers :</p>\n<ul>\n<li><code>EnedisDataConnectProvider</code> : Qui nous retournera les consommations de notre compteur Linky.</li>\n<li><code>GrdfGazparProvider</code> : Qui nous retournera les consommations de notre compteur Gazpar.</li>\n</ul>\n<p>Voici un schéma pour mieux comprendre :</p>\n<p><figure class=\"post__image\"><img loading=\"lazy\" src=\"https://gwennael-jean.github.io/media/posts/1/UML-Strategy-2.png\" sizes=\"(max-width: 48em) 100vw, 768px\" srcset=\"https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-xs.png 300w ,https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-sm.png 480w ,https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-md.png 768w ,https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-lg.png 1024w ,https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-xl.png 1360w ,https://gwennael-jean.github.io/media/posts/1/responsive/UML-Strategy-2-2xl.png 1600w\"  alt=\"Image description\" width=\"643\" height=\"361\" /></figure></p>\n<p>Sur ce diagramme, nous retrouvons notre service <code>ExternalConsommationProvider</code> (Le gros bloc jaune toute en haut).\nCelui-ci contiendra une liste de providers (la propriété visible via le petit carré rouge).\nChaque provider sera une instance de <code>ConsommationProviderInterface</code> (le bloc jaune au milieu).\nCe qui obligera chaque provider de développer 2 méthodes (<code>support()</code> et <code>findByRange()</code>).\nEnfin, nous retrouvons nos 2 providers <code>EnedisDataConnectProvider</code> et <code>GrdfGazparProvider</code>\n(chacun implémentant l’interface en question, symbolisé par la flèche en pointillé).</p>\n<p>L’objectif de notre service <code>ExternalConsommationProvider</code> est, via sa méthode <code>findByRange</code>,\nde nous retourner les consommations. Sans même avoir développer nos 2 providers,\nnous pouvons déjà développer cette méthode :</p>\n<pre><code class=\"language-php\">public function findByRange(Logement $logement, DateTime $start, DateTime $end, User $user): array\n{\n    $consommations = [];\n\n    foreach ($this-&gt;getProviders() as $provider) {\n        if ($provider-&gt;support($logement, $user)) {\n            $consommations = array_merge(\n                $consommations,\n                $provider-&gt;findByRange($logement, $start, $end, $user)\n            );\n        }\n    }\n\n    return $consommations;\n}\n</code></pre>\n<p>Voyons ce code : on boucle sur les providers de notre service.\nSi chaque provider est supporté (pour résumer, si l’utilisateur souhaite obtenir les\nconsommations depuis ce provider), on ajoute dans notre tableau <code>$consommations</code> les\nconsommations récupéré grâce au provider.</p>\n<p>En ce qui concerne nos providers, il suffit de développer les méthodes obtenues grâce à notre interface :</p>\n<pre><code class=\"language-php\">class EnedisDataConnectProvider implements ConsommationProviderInterface\n{\n    public function support(Logement $logement, User $user): bool\n    {\n        // On vérifie si notre logement est bien connecté au compteur Linky\n    }\n\n    public function findByRange(Logement $logement, DateTime $start, DateTime $end, User $user): array\n    {\n        // On retourne les consommations de notre compteur Linky grâce à l&#39;API Data Connect d&#39;Enedis\n    }\n}\n</code></pre>\n<p>Maintenant que nous avons implémenté notre service <code>ExternalConsommationProvider</code> ainsi que nos 2 providers,\ncomment intégrer ces providers dans notre service ?</p>\n<p>C’est là qu’intervient le Compiler Pass de Symfony.</p>\n<h1 id=\"le-compiler-pass\">Le Compiler Pass</h1>\n<p>Pour ajouter un provider à notre service, nous disposons de la méthode <code>addProvider()</code>, qui attends\nen paramètre une instance de <code>ConsommationProviderInterface</code>.</p>\n<p>Avec Symfony, nous avons la possibilité de tagger nos services, afin de les identifier plus\nfacilement dans notre application.</p>\n<p>Nous allons donc ajouter un tag sur tous nos services implémentant l’interface\n<code>ConsommationProviderInterface</code>. Pour cela, il suffit d’ajouter les lignes suivantes dans\nnotre fichier <code>config/services.yaml</code> :</p>\n<pre><code class=\"language-yaml\">_instanceof:\n  App\\Service\\ConsommationProviderInterface:\n    tags: [ app.rt2012.external_consommation_provider ]\n</code></pre>\n<p>Ainsi, nos 2 providers auront le tags <code>app.rt2012.external_consommation_provider</code>.</p>\n<p>Maintenant que nous pouvons identifier nos providers, nous pouvons créer un CompilerPass.\nPour cela, Créons la class <code>ExternalConsommationProviderPass</code> comme ceci :</p>\n<pre><code class=\"language-php\">class ExternalConsommationProviderPass implements CompilerPassInterface\n{\n    public function process(ContainerBuilder $container)\n    {\n        if (!$container-&gt;has(ExternalConsommationProvider::class)) {\n            return;\n        }\n\n        $definition = $container-&gt;findDefinition(ExternalConsommationProvider::class);\n\n        $taggedServices = $container-&gt;findTaggedServiceIds(&#39;app.rt2012.external_consommation_provider&#39;);\n\n        foreach ($taggedServices as $id =&gt; $tags) {\n            $definition-&gt;addMethodCall(&#39;addProvider&#39;, [new Reference($id)]);\n        }\n    }\n}\n</code></pre>\n<p>Dans notre méthode <code>process()</code>, nous vérifions si le service <code>ExternalConsommationProvider</code> existe.\nEnsuite, nous récupérons tous les services tagués sous le nom <code>app.rt2012.external_consommation_provider</code>,\nsoit nos 2 providers. Enfin, nous bouclons sur ces services pour les ajouter dans notre service\n<code>ExternalConsommationProvider</code> grâce à la méthode <code>addProvider()</code>.</p>\n<p>Pour terminer, il faut que notre application prenne en compte ce CompilerPass. Pour cela,\nil suffit de l’ajouter dans le container, via la méthode <code>build</code> de la class <code>App\\Kernel</code> :</p>\n<pre><code class=\"language-php\">class Kernel extends BaseKernel\n{\n    public function build(ContainerBuilder $container)\n    {\n        $container-&gt;addCompilerPass(new ExternalConsommationProviderPass());\n    }\n}\n</code></pre>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>L’intérêt principal du design pattern Strategy est de nous permettre d’ajouter autant de\nprovider que nous le souhaitons. Imaginons que, demain, Qualitel nous demande d’afficher\nles consommations d’une autre API, nous n’aurons qu’à créer un provider implémentant\nl’interface <code>ConsommationProviderInterface</code>. Celui-ci sera automatiquement tagué et\ninséré dans notre service <code>ExternalConsommationProvider</code> grâce au CompilerPass.</p>\n",
            "author": {
                "name": "Gwennael Jean"
            },
            "tags": [
                   "Développement"
            ],
            "date_published": "2022-01-24T10:26:00+01:00",
            "date_modified": "2022-01-28T09:26:47+01:00"
        },
        {
            "id": "https://gwennael-jean.github.io/les-commentaires.html",
            "url": "https://gwennael-jean.github.io/les-commentaires.html",
            "title": "Les commentaires",
            "summary": "Introduction L’idée est de pouvoir laisser les visiteurs publier des commentaires sur différents articles. Sur chaque article, nous afficherons un mini formulaire permettant aux lecteurs de publier des commentaires. Ce formulaire sera composé de 3 champs : Pour un utilisateur connecté, nous n’afficherons que le&hellip;",
            "content_html": "<h1 id=\"introduction\">Introduction</h1>\n<p>L’idée est de pouvoir laisser les visiteurs publier des commentaires sur différents articles.</p>\n<h1 id=\"partie-clients\">Partie clients</h1>\n<p>Sur chaque article, nous afficherons un mini formulaire permettant aux lecteurs de publier des commentaires. Ce formulaire sera composé de 3 champs :</p>\n<ul>\n<li>Nom</li>\n<li>Adresse Email</li>\n<li>Commentaire</li>\n</ul>\n<p>Pour un utilisateur connecté, nous n’afficherons que le champ Commentaire.</p>\n<p>Sous ce formulaire, nous afficherons les commentaires.</p>\n<p>Pour nous aider à la gestion des commentaires, nous utiliserons <a href=\"https://akismet.com/\">Akismet</a>.</p>\n<h1 id=\"partie-admin\">Partie Admin</h1>\n<h2 id=\"crud-des-commentaires\">CRUD des commentaires</h2>\n<p>Sur le BO, nous aurons une partie consacré à la gestion des commentaires. Nous pourrons choisir Afficher / Bloquer / Supprimer un commentaire.</p>\n<ul>\n<li>Les commentaires Afficher seront, par définition, affiché sur le site</li>\n<li>Les commentaires Bloquer ne seront pas affiché sur le site</li>\n<li>Les commentaires Supprimer seront supprimé de la base de données</li>\n</ul>\n<h2 id=\"activation-des-commentaires-sur-chaque-article\">Activation des commentaires sur chaque article</h2>\n<p>Depuis la page article, les utilisateurs pourront, s’ils le souhaitent, activer ou désactiver la publication de commentaire. Ils pourront également autoriser, s’ils le souhaitent, la publication de commentaire uniquement aux utilisateurs connecté.</p>\n<p>Par défaut, les commentaires seront activé sur les articles, mais seront désactiver sur les brèves et les pages.</p>\n<h2 id=\"paramétrage-des-commentaires\">Paramétrage des commentaires</h2>\n<p>Une page de paramétrage sera accessible pour les administrateurs. Il sera possible, depuis cette page paramètres de :</p>\n<ul>\n<li>Indiquer la clé Akismet</li>\n<li>Indiquer le nombre de commentaires affiché par page</li>\n<li>Indiquer le tri des commentaires (tri par date de publication ASC / DESC)</li>\n<li>Indiquer certains mot clé interdit dans les commentaires (par exemple : Connard / Abruti / Kita / …)</li>\n</ul>\n<h2 id=\"a-propos-dakismet\">A propos d’Akismet</h2>\n<p>Akismet est une API permettant de détécter les spams. Chaque publication de commentaire sera soumis à Akismet.\nElle est gratuite pour un usage non commercial. Ce qui veut dire que nous devrons payer une licence le jour ou :</p>\n<ul>\n<li>Nous aurons des pubs sur le site</li>\n<li>Nous Aurons une boutique en ligne</li>\n</ul>\n",
            "author": {
                "name": "Gwennael Jean"
            },
            "tags": [
                   "Maison Jaune"
            ],
            "date_published": "2022-01-17T19:39:27+01:00",
            "date_modified": "2022-01-25T14:57:25+01:00"
        }
    ]
}
